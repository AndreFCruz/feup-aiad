/* Generated By:JJTree: Do not edit this line. SimpleNode.java */

package uchicago.src.sim.parameter.rpl;

import ViolinStrings.Strings;

public class SimpleNode implements Node {
  protected Node parent;
  protected Node[] children;
  protected int id;
  protected RPLParser parser;
  protected int beginLine, endLine, beginColumn, endColumn;
  Object info;

  public SimpleNode(int i) {
    id = i;
  }

  public SimpleNode(RPLParser p, int i) {
    this(i);
    parser = p;
  }

  public void jjtOpen() {
  }

  public void jjtClose() {
  }

  public void jjtSetParent(Node n) {
    parent = n;
  }

  public Node jjtGetParent() {
    return parent;
  }

  public void jjtAddChild(Node n, int i) {
    if (children == null) {
      children = new Node[i + 1];
    } else if (i >= children.length) {
      Node c[] = new Node[i + 1];
      System.arraycopy(children, 0, c, 0, children.length);
      children = c;
    }
    children[i] = n;
  }

  public Node jjtGetChild(int i) {
    return children[i];
  }

  public int jjtGetNumChildren() {
    return (children == null) ? 0 : children.length;
  }

  /* You can override these two methods in subclasses of SimpleNode to
     customize the way the node appears when the tree is dumped.  If
     your output uses more than one line you should override
     toString(String), otherwise overriding toString() is probably all
     you need to do. */

  public String toString() {
    return RPLParserTreeConstants.jjtNodeName[id];
  }

  public String toString(String prefix) {
    return prefix + toString();
  }

  /* Override this method if you want to customize how the node dumps
     out its children. */

  public void dump(String prefix) {
    System.out.println(toString(prefix));
    if (children != null) {
      for (int i = 0; i < children.length; ++i) {
        SimpleNode n = (SimpleNode) children[i];
        if (n != null) {
          n.dump(prefix + " ");
        }
      }
    }
  }

  public Object getInfo() {
    return info;
  }

  public void setInfo(Object o) {
    info = o;
    //System.out.println("name: "+info);
  }


  public void setString(String s, int quotes) {
    info = parseString(s, quotes);
  }

  public String parseString(String s, int quotes) {
    String val = s.substring(quotes, s.length() - quotes);
    val = Strings.change(val, "\\n", "\n");
    val = Strings.change(val, "\\\"", "\"");
    val = Strings.change(val, "\\t", "\t");
    val = Strings.change(val, "\\r", "\r");

    return val;
  }

  public void setInteger(String s, int radix) {
    if (s.endsWith("L") || s.endsWith("l")) {
      s = s.substring(0, s.length() - 1);
      try {
        setInfo(Long.valueOf(s, radix));
      } catch (NumberFormatException ex) {
        String message = "Error creating long value";
        throwError(message, ex);
      }
    } else {
      int ndigits = s.length();
      int i = 0;
      while (i < ndigits && s.charAt(i) == '0') i++;
      if ((ndigits - i) > 11) {
        throwError("Integer literal too large");
      }

      long l = Long.valueOf(s, radix).longValue();
      if (l > 0xffffffffl || (radix == 10 && l > Integer.MAX_VALUE)) {
        throwError("Integer literal too large");
      }
      setInfo(new Integer((int) l));
    }
  }


  public void setFloat(String s) {
    if (s.endsWith("F") || s.endsWith("f")) {
      s = s.substring(0, s.length() - 1);
      try {
        setInfo(Float.valueOf(s));
      } catch (NumberFormatException ex) {
        String message = "Error creating float value";
        throwError(message, ex);
      }
    } else {
      setInfo(Double.valueOf(s));
    }
  }

  public RPLObject getValue() {
    throw new UnsupportedOperationException(this.getClass().getName() + " does not" +
                                            " support getValue()");
  }

  public void preProcess(RPLCompiler compiler) {
    throw new UnsupportedOperationException(this.getClass().getName() + " does not" +
                                            " support compile()");
  }


  public void compile(RPLCompiler compiler) {
    throw new UnsupportedOperationException(this.getClass().getName() + " does not" +
                                            " support compile(RPLCompiler)");
  }

  protected void throwError(String message) {
    throw new CompilerException("Error at line " + this.endLine +
                                " " + message);
  }

  protected void throwError(String message, Exception ex) {
    throw new CompilerException("Error at line " + this.endLine +
                                " " + message, ex);
  }
}

